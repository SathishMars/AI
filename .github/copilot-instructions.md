# Groupize Embed - AI Agent Instructions

## Project Overview

This is a Next.js 16+ embeddable frontend application designed to gradually migrate features from a Ruby on Rails monolith. The app is built to be embedded in RoR pages via script tags while maintaining independent functionality.

**Tech Stack:**
- Next.js 16 with App Router and Turbopack (repository uses `next` v16.0.6)
- React 19.2 with strict mode
- TypeScript with strict mode
- shadcn/ui for components (built on Radix UI primitives)
- Tailwind CSS v4 for styling  
- MongoDB 8.0 (local development) / AWS DocumentDB 8 (production) with connection pooling
- AI SDK with OpenAI and Anthropic for AI processing
- JWT-based session management

## Key Architecture Patterns

### Embeddable Design
- Build components that can function within script tag contexts
- Consider viewport constraints and parent page styling conflicts
- Use `viewport` metadata in layout.tsx to prevent scaling issues in embedded contexts
- Test components both standalone and embedded

### Styling Strategy
- Use shadcn/ui components as the foundation (built on Radix UI primitives)
- Leverage Tailwind CSS v4 for all styling and layout
- Use CSS variables for theming (defined in globals.css)
- Follow wireframes or UI designs mentioned in the stories closely
- Maintain a uniform look and feel across all components and pages
- Allow for custom themes via CSS variable overrides

### Component Architecture
- **shadcn/ui Philosophy**: Copy components into your project for full customization
- **Component Location**: shadcn/ui components are installed to `@/components/ui`
- **Utilities**: Use `cn()` utility from `@/lib/utils` for conditional class merging
- **Icons**: Use Lucide React for consistent iconography
- **Theming**: Theme switching via CSS class on root element (`light` or `dark`)
- **Adding Components**: Use `npx shadcn@latest add <component>` to add new UI components

### Workflow Architecture
**Multi-Step Workflow System**: Build workflows with conditional branching and pre-built function integration

**ðŸ“š COMPLETE ARCHITECTURE DOCUMENTATION**: See `ai-implementation-summaries/WORKFLOW-ARCHITECTURE-INDEX.md` for master index of all architecture docs

**Quick Reference:**
- **Core Components**: Workflow builder UI, rule engine, AI processing, visualization, execution engine
- **Rules Engine**: **CRITICAL**: All workflow rules MUST use `json-rules-engine` for evaluation. AI-generated rules should produce valid json-rules-engine schema format
- **AI Integration**: Use OpenAI/Anthropic for natural language to JSON workflow conversion (json-rules-engine format) and Mermaid flowchart generation
- **Visualization**: Use `react-md-editor` (https://github.com/uiwjs/react-md-editor) for markdown viewing with Mermaid support
- **Execution**: Step-by-step workflow execution with success/failure branching using `json-rules-engine` (https://github.com/CacheControl/json-rules-engine) evaluation
- **Data Structure**: Workflows stored as nested arrays (NOT numbered object keys)
- **Step Numbering**: Tree-based numbering (1, 1.1, 1.1.1) generated dynamically from nested array indices for UI display only
- **Step IDs**: Human-readable IDs (e.g., "checkBudget", "sendApprovalEmail") generated by LLM for clear step references
- **Step References**: Use step IDs in `onSuccessGoTo` and `onFailureGoTo` fields (e.g., `onSuccessGoTo: "createEventAction"`)
- **Step Naming**: Professional naming convention: "Start:", "Check:", "Action:", "End:" prefixes (NO emojis in names)
- **Workflow Triggering**: Workflows can trigger other workflows within the same account using `type: "workflow"` steps with `workflowId` parameter
- **Template Structure**: Templates have separate ID (10-char short-id, auto-generated) and NAME (user-editable)

### ID generation

- **MANDATORY**: All generated short IDs (the 10-char template `id` and any other short identifiers used across the codebase) MUST be produced using the `short-unique-id` package to guarantee consistent, testable, and dependency-tracked identifiers. Do not roll or invent ad-hoc generators in multiple files.

- Version to use: the repository currently uses `short-unique-id@^5.3.2` (check `package.json` before adding/updating). Use that exact major version range unless you coordinate a bump.

- Recommended TypeScript usage (example):

```ts
import ShortUniqueId from 'short-unique-id';

// create a reusable generator (do not recreate inside tight loops)
const uid = new ShortUniqueId({ length: 10, dictionary: 'alphanum' });

// generate a 10-char short id
const templateId = uid(); // e.g. 'aB3k9ZpQ1x'
```

- Policy notes:
  - Reuse a single `ShortUniqueId` instance where possible (e.g., in a util) instead of instantiating repeatedly.
  - Prefer the `alphanum` dictionary and length 10 to match existing DB indexes and expectations.
  - Always `import` from the top-level package name (`'short-unique-id'`) and avoid copying the implementation.
  - If you must change the generator settings (length/dictionary), update `copilot-instructions.md` and the integration tests that assert ID length/format.
- **Metadata Separation**: Workflow definition contains ONLY steps - NO duplicated account/org/name metadata
- **Version Management**: Only 1 published + max 1 draft per template ID; others become archived/deprecated
- **Auto-Save Rules**: Save only when workflow has â‰¥1 real step AND template is named (not 'new'/'create')
- **Data Separation**: AIME conversations stored separately from workflow templates in distinct collection
- **Conversation Autosave**: Persist conversation messages only for user input and completed aime responses; streaming or placeholder system messages must not trigger autosave. Loading conversations with `setState` should be done without re-triggering saves unless explicitly requested with `triggerAutosave`.
- **Rule condition schema** (JSON Schema format - $ref are schema references, not tool references):
<!-- markdownlint-disable -->
```json
{
  "title": "JsonRulesEngine Rule Schema",
  "description": "Schema for validating rules used by json-rules-engine",
  "type": "object",
  "required": ["conditions", "event"],
  "properties": {
    "conditions": {
      "type": "object",
      "properties": {
        "all": {
          "type": "array",
          "items": { "$ref": "#/definitions/condition" }
        },
        "any": {
          "type": "array",
          "items": { "$ref": "#/definitions/condition" }
        }
      },
      "minProperties": 1,
      "additionalProperties": false
    },
    "event": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": { "type": "string" },
        "params": { "type": "object" }
      },
      "additionalProperties": false
    },
    "priority": { "type": "integer", "minimum": 1 },
    "onSuccess": { "type": "string" },
    "onFailure": { "type": "string" }
  },
  "definitions": {
    "condition": {
      "type": "object",
      "properties": {
        "all": {
          "type": "array",
          "items": { "$ref": "#/definitions/condition" }
        },
        "any": {
          "type": "array",
          "items": { "$ref": "#/definitions/condition" }
        },
        "fact": { "type": "string" },
        "operator": { "type": "string" },
        "value": {},
        "path": { "type": "string" },
        "params": { "type": "object" }
      },
      "minProperties": 1,
      "additionalProperties": false
    }
  }
}
```
<!-- markdownlint-enable -->
- **Workflow Template Structure**:
```json
{
  // Template Metadata (database only, NOT in workflowDefinition)
  "id": "a1b2c3d4e5",           // 10-char short-id (auto-generated, not user-visible)
  "account": "company123",       // Company identifier
  "organization": "dept456",     // Department (null = account-wide)
  "name": "Event Approval Flow", // User-editable name
  "status": "draft",             // draft|published|deprecated|archived
  "version": "1.0.0",            // Semantic version
  
  // Clean Workflow Definition (NO duplicated metadata)
  // Steps stored as nested arrays - numbering (1, 1.1, 1.1.1) generated from indices for UI only
  // Each step has human-readable ID (LLM-generated) for clear referencing
  "workflowDefinition": {
    "steps": [
      {
        "id": "mrfSubmissionTrigger",      // Human-readable ID (LLM-generated)
        "name": "Start: On MRF Submission",  // Professional naming with prefix
        "type": "trigger",
        "action": "onMRFSubmit",
        "params": { "mrfTemplateName": "all" },
        "children": [
          {
            "id": "checkAttendeeCount",
            "name": "Check: Attendees Over 100",
            "type": "condition",
            "condition": {
              "all": [
                { "fact": "form.numberOfAttendees", "operator": "greater than", "value": 100 }
              ]
            },
            "onSuccess": {
              "id": "requestManagerApproval",
              "name": "Action: Request Manager Approval",
              "type": "action",
              "action": "requestApproval",
              "params": { "to": "manager@example.com" },
              "onSuccessGoTo": "createEventAction",  // Reference by human-readable ID
              "onFailureGoTo": "workflowEnd"         // Reference by ID
            },
            "onFailure": {
              "id": "createEventAction",
              "name": "Action: Create Event",
              "type": "action",
              "action": "createEvent",
              "params": { "mrfID": "dynamic" }
            }
          }
        ]
      },
      {
        "id": "workflowEnd",
        "name": "End: Workflow Complete",
        "type": "end",
        "action": "terminateWorkflow",
        "params": { "result": "success" }
      }
    ]
  },
  
  "mermaidDiagram": "...",       // Auto-generated
  "metadata": { /* timestamps, author, etc */ }
}
``` 

## Development Workflow

 - **Manual Change Awareness**
 - Assume files may contain manual adjustments that differ from cached or previously seen versions.
 - Always read the current code before applying updates and reconcile differences instead of overwriting custom logic.
 - **Formatting rule (MANDATORY)**: After finishing any code modification in the repository, always run the project's default formatter (the one the repository is configured to use) on the modified files and save the formatted results before committing. This ensures consistent style and reduces unrelated diffs.
- Always read the current code before applying updates and reconcile differences instead of overwriting custom logic.

### Build Commands
- Development: `npm run dev` (uses Turbopack for fast builds - no --turbopack flag needed)
- Production: `npm run build` (uses Turbopack - no --turbopack flag needed)
- Linting: `npm run lint`

### File Organization (App Router Structure)
- **App Router**: Use `src/app/` directory with Next.js 16 App Router conventions
- **Import path alias**: `@/*` maps to `./src/*`
- **Components**: Reusable components go in `src/app/components/`
- **Utilities**: Helper functions and utilities in `src/app/utils/`
- **Validators**: Form validation schemas in `src/app/validators/`
- **Types**: TypeScript type definitions in `src/app/types/`
- **Tests**: Mirror source structure in `src/test/` (e.g., `src/test/app/components/`)
- **API Routes**: Use `src/app/api/` for backend API routes
- **Global Styles**: Tailwind imports and CSS variables in `src/app/globals.css`
- **Layout**: Main layout and metadata in `src/app/layout.tsx`
- **Pages**: Each page or route in its own folder under `src/app/` (e.g., `src/app/workflow-builder/page.tsx`)
- **Story & Epic Management**: Store user stories and epics in `user-stories/` folder at project root (outside `src/`)
- **AI Implementation Summaries**: Store AI implementation notes and summaries in `ai-implementation-summaries/` folder at project root (outside `src/`)
  - **IMPORTANT**: Do NOT automatically generate implementation summary markdown files unless explicitly requested by the developer
  - Only create summaries when the developer specifically asks for documentation
- **Database Scripts**: Store all database scripts, migrations, and SQL files in `db-scripts/` folder at project root (outside `src/`)
- **Critical Files**:
  - `src/app/layout.tsx` - Main layout with font loading and metadata
  - `src/app/globals.css` - Tailwind imports and CSS variables
  - `next.config.ts` - Next.js configuration (currently minimal)
  - `package.json` - Dependencies and build scripts (CHECK BEFORE ADDING NEW PACKAGES)
  - `user-stories/` - User stories and epics (outside src folder)
  - `ai-implementation-summaries/` - AI implementation notes and summaries (outside src folder)


## Package Management

### Dependency Guidelines
**CRITICAL**: Always check `package.json` before adding new packages to avoid duplicating functionality.
**CRITICAL**:  Before creating new code, always check existing folders for reusable components, utilities, validators, and types.


### Version Compliance Requirements
**MANDATORY**: When recommending or writing code, ALWAYS reference the EXACT versions specified in `package.json`. Never assume or use outdated API patterns.

**Current Exact Versions (as of package.json) (MongoDB driver upgraded for AWS DocumentDB 8 compatibility):**
- **Next.js**: `16.0.6` - Use App Router patterns, Turbopack features (matches `package.json`)
- **React**: `19.2.0` - Follow React 19 patterns and hooks (matches `package.json`)
- **React DOM**: `19.2.0` - Matches React version (matches `package.json`)
- **shadcn/ui**: Latest - Built on Radix UI primitives with Tailwind CSS (v1.2+ components)
- **Lucide React**: `^0.552.0` - Icon library for shadcn/ui components
- **Tailwind CSS**: `^4` - Use Tailwind v4 syntax and features
- **Zod**: `^4` - Use Zod v4 API for validation (matches `package.json`)
- **TypeScript**: `^5` - Use TypeScript 5 features
- **AI SDK**: `@ai-sdk/react@^2.0.87`, `@ai-sdk/anthropic@^2.0.41` - Use latest AI SDK patterns
- **MongoDB**: `mongodb@^6.12.0` - Driver aligned to MongoDB 8.x API surface (AWS DocumentDB 8 compatible)
- **json-rules-engine**: `^7.3.1` - Use v7 API for workflow rules
- **react-md-editor**: `@uiw/react-md-editor@^4.0.8` - Use v4 API
- **Mermaid**: `^11.12.0` - Use Mermaid v11 syntax
- **Testing Libraries**: `@testing-library/react@^16.3.0`, `jest@^30.2.0`

**Before Adding New Packages:**
1. **Version Check**: Review `package.json` for exact versions FIRST
2. **API Compatibility**: Ensure code examples match the installed versions
3. **Dependency Conflicts**: Verify compatibility with current versions (especially Zod v4, React 19, shadcn/ui)
4. **Bundle Size**: Consider impact for embedded contexts
5. **Peer Dependencies**: Use `npm install --legacy-peer-deps` if needed
6. **Documentation**: Update this list when adding major new dependencies

**Code Recommendation Rules:**
- Always check `package.json` before suggesting imports or API usage
- Use version-specific documentation and examples
- Test code suggestions against installed versions
- Flag potential version conflicts in recommendations
- Flag potential IP infringements

## Code Quality Requirements

### Testing Standards
- **90% minimum code coverage required**
- Write tests for all components, utilities, and API routes
- Test both standalone and embedded behavior
- Include integration tests for PostgreSQL interactions

### Regression Testing Requirements
**CRITICAL**: After implementing or modifying any functionality:

1. **Run Complete Test Suite**: Execute ALL test cases (not just new ones) to ensure no unintended breaking changes
   ```bash
   npm test
   ```

2. **Fix Broken Tests**: If existing tests fail due to new functionality:
   - Analyze WHY the test is failing (intended behavior change vs. regression)
   - Update test cases to reflect new intended behavior
   - Document test changes in commit messages or implementation summaries

3. **Verify Test Coverage**: Ensure new functionality has comprehensive test coverage:
   - Unit tests for utilities and functions
   - Component tests for UI elements
   - Integration tests for API routes
   - Edge case tests for error handling

4. **Document Test Results**: Include test summary in implementation documentation:
   - Number of tests passing before changes
   - Number of tests passing after changes
   - Any tests modified or added
   - Confirmation that full test suite passes

**Example Workflow**:
```bash
# 1. Run all tests before starting
npm test

# 2. Implement feature/fix

# 3. Run all tests again
npm test

# 4. Fix any broken tests

# 5. Add new tests for new functionality

# 6. Final verification - all tests passing
npm test
```

**Why This Matters**:
- Prevents regression bugs from reaching production
- Ensures new features don't break existing functionality
- Maintains confidence in codebase stability
- Catches edge cases and integration issues early
- Provides documentation of working state

### TypeScript Configuration
- Strict mode enabled - handle all type errors
- Use ES2017 target for broad compatibility
- Prefer explicit typing over `any`

### Development Server Guidelines
- **CRITICAL: Never automatically start server runtimes** - AI tools should NOT use `npm run dev`, `npm start`, or similar commands to start development servers
- **Ask developer to test**: When code changes are complete, instruct the developer to start the server manually to test the updates
- **Exception**: Only use `run_in_terminal` for server commands if explicitly requested by the developer
- **Testing**: Use `npm test` for automated testing, but avoid starting long-running processes automatically

## Migration Context

### Rails Integration Points
- Design APIs that can be consumed by both Rails and Next.js
- Use JWT tokens compatible with existing Rails authentication
- Maintain consistent data models between Rails and MongoDBand PostgreSQL schemas
- Plan for gradual feature migration - build components that can replace Rails views

### Session Management
- Implement JWT-based authentication
- Ensure token compatibility with Rails backend
- Handle both embedded and standalone authentication flows

## Development Guidelines


### Responsiveness Requirement
- All screens in the application must be responsive and handle phone, tablet, and computer screen configurations.

### Component Development
1. **Check existing code first**: Scan `src/app/components/`, `src/app/utils/`, `src/app/validators/`, and `src/app/types/` for reusable code
2. **Version-specific development**: Always check `package.json` for exact versions before writing code - use version-specific APIs and patterns
3. **Check package.json**: Review existing dependencies before adding new packages with similar functionality
4. Start with shadcn/ui components as the foundation
5. Use Tailwind v4 for creating styled components and layout and spacing adjustments
6. Place reusable components in `src/app/components/`
7. Extract form validators to `src/app/validators/` (use Zod v4 API)
8. Define TypeScript types in `src/app/types/`
9. Ensure components work in embedded contexts
10. For workflow components: Build and update workflow components using the AI chat functionality.
11. **CRITICAL: Always validate and update existing test cases** - When creating or updating any component, check `src/test/` for existing test files and update them to match new functionality. Create comprehensive tests if none exist.
12. Write comprehensive tests in `src/test/` mirroring source structure using current testing library versions

### Database Integration
- **Connection Pool**: ALWAYS use the MongoDB connection pool utility (`@/app/utils/mongodb-connection`) for ALL database operations
- **MongoDB/DocumentDB Version**: Use MongoDB 8.0 compatible syntax and features (AWS DocumentDB 8 released November 2025)
- **Environment Support**: Support both local MongoDB 8.0+ and AWS DocumentDB 8 based on environment flags
- **Connection Pattern**: 
  ```typescript
  import { getMongoDatabase } from '@/app/utils/mongodb-connection';
  const db = await getMongoDatabase();
  const collection = db.collection('collectionName');
  ```
- **Query Syntax**: Use MongoDB 8.0 compatible aggregation pipelines, operators, and query syntax
  - **Collation is NOW FULLY SUPPORTED** in DocumentDB 8: Use native collation for case-insensitive operations (no workarounds needed)
  - **New aggregation stages now supported**: `$bucket`, `$bucketAuto`, `$merge`, `$set`, `$unset`, `$replaceWith` available in DocumentDB 8
  - **New aggregation operators in DocumentDB 8**: `$pow`, `$rand`, `$dateTrunc` (use these for DocumentDB 8+ deployments)
  - Still avoid: `$facet`, `$graphLookup`, `$setWindowFields`, and advanced window operators not yet supported
  - Vector indexes via `$vectorSearch` and `$search` now supported in DocumentDB 8
  - Use explicit `$sort` for consistent ordering (DocumentDB does not guarantee implicit ordering)
  - Use `$lookup` for equality joins and uncorrelated subqueries; avoid correlated subqueries
  - Explicitly specify `$exists` when leveraging sparse indexes for proper index utilization
- **Collation Support**: DocumentDB 8 now supports full collation specification
  ```typescript
  // Example: Case-insensitive sort with collation (DocumentDB 8+)
  db.collection('users').find({}).collation({ locale: 'en', strength: 2 }).sort({ name: 1 })
  
  // Example: Case-insensitive aggregation with collation (DocumentDB 8+)
  db.collection('users').aggregate([
    { $sort: { name: 1 } },
    { $group: { _id: null, users: { $push: '$$ROOT' } } }
  ], { collation: { locale: 'en', strength: 2 } })
  ```
- **Error Handling**: Always wrap database operations in try-catch blocks with proper MongoDB error handling
  - Treat `MongoServerError` code 9 (`Unrecognized field: 'txnNumber'`) as indication of retryable writes misconfiguration
  - Fallback behavior for unsupported commands should degrade gracefully
- **Schema Design**: Design schemas that align with existing Rails models for gradual migration
- **Data Migration**: Plan for data migration scenarios between PostgreSQL and MongoDB
- **Database Scripts**: **CRITICAL** - When user stories require new database objects (collections, indexes, migrations, etc.), ALL database operations must be scripted and stored in the `db-scripts/` folder at project root. Include collection creation scripts, index definitions, data migration scripts, and usage examples. Never create database objects directly in application code without corresponding scripts in `db-scripts/`.
  - Index definitions can now include case-insensitive indexes (new in DocumentDB 8): `createIndex({ name: 1 }, { collation: { locale: 'en', strength: 2 } })`
  - Compound and multikey indexes are fully supported
  - TTL indexes for automatic document expiration are supported
- **AI-Generated Documentation**: **CRITICAL** - All AI-generated documentation, implementation summaries, usage examples, and explanatory markdown files must be stored in the `ai-implementation-summaries/` folder at project root (outside `src/`). This includes documentation generated during development, implementation notes, and any markdown files that explain code or provide usage examples. Only executable scripts should remain in `db-scripts/` - all documentation belongs in `ai-implementation-summaries/`.

### Performance Considerations
- Leverage Turbopack for development speed
- Optimize for embedded loading performance
- Consider bundle size impact on parent pages

### Git and Version Control
- **Commit Messages**: Use concise, clear summaries of changes
- **No Iconography**: Avoid emojis, symbols, or decorative characters in commit messages
- **Professional Format**: Write commit messages suitable for enterprise development environments
- **Example Format**: "Add user authentication middleware" or "Fix workflow validation logic"
- **Avoid**: Long multi-paragraph commit messages, emoji usage, excessive formatting

## User Stories and Epic Management

### Story Organization
- Store all user stories and epics in `user-stories/` folder in project root (outside `src/`)
- Use consistent naming: `epic-[name].md` for epics, `story-[name].md` for user stories.
- Link child stories to parent epics for traceability

### User Story Template
```markdown
# User Story: [Title]

**As a** [user type]  
**I want** [functionality]  
**So that** [benefit/value]

## Summary
[One-line summary of functionality]

## Feature 
[Name of feature this story belongs to]
[if the feature does not exist in the user-stories/ folder, omit this section]

## Epic
[Epic name if this story is part of an epic - link to epic file]
[if the epic does not exist in the user-stories/ folder, omit this section]

## UI Considerations
[UI/UX requirements, accessibility, responsiveness, or design notes]

## Acceptance Criteria
- [ ] [Specific, testable criteria]
- [ ] [Additional criteria]

## Developer Notes
[Notes added during development - implementation details, decisions, blockers]

### Security Notes
[Any security considerations, authentication requirements, data protection measures, or vulnerability mitigation strategies specific to this story]
```

**Instructions:**
- Omit the "Epic" section if there are no epics in the `user-stories/` folder to reference.
- Always include a "UI Considerations" section before "Acceptance Criteria" in every user story if applicable.



## Critical Files
- `src/app/layout.tsx` - Main layout with font loading and metadata
- `src/app/globals.css` - Tailwind imports and CSS variables
- `next.config.ts` - Next.js configuration (currently minimal)
- `package.json` - Dependencies and build scripts (CHECK BEFORE ADDING NEW PACKAGES)
- `user-stories/` - User stories and epics (outside src folder)
- `ai-implementation-summaries/` - AI implementation notes and summaries (outside src folder)
